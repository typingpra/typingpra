// snippets.js - プログラミング言語のコードスニペット定義

const SNIPPETS = {
	python:
		'import datetime\nimport json\nfrom enum import Enum\nfrom typing import List, Optional, Dict\n\nclass Priority(Enum):\n    LOW = 1\n    MEDIUM = 2\n    HIGH = 3\n    URGENT = 4\n\nclass TaskStatus(Enum):\n    PENDING = "pending"\n    IN_PROGRESS = "in_progress"\n    COMPLETED = "completed"\n    CANCELLED = "cancelled"\n\nclass Task:\n    def __init__(self, title: str, description: str = "", \n                 priority: Priority = Priority.MEDIUM):\n        self.id = self._generate_id()\n        self.title = title\n        self.description = description\n        self.priority = priority\n        self.status = TaskStatus.PENDING\n        self.created_at = datetime.datetime.now()\n        self.updated_at = self.created_at\n        self.due_date: Optional[datetime.datetime] = None\n        self.tags: List[str] = []\n    \n    def _generate_id(self) -> str:\n        return f"task_{datetime.datetime.now().strftime(\'%Y%m%d_%H%M%S\')}"\n    \n    def update_status(self, status: TaskStatus):\n        self.status = status\n        self.updated_at = datetime.datetime.now()\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n    \n    def set_due_date(self, due_date: datetime.datetime):\n        self.due_date = due_date\n    \n    def is_overdue(self) -> bool:\n        if self.due_date and self.status != TaskStatus.COMPLETED:\n            return datetime.datetime.now() > self.due_date\n        return False\n    \n    def to_dict(self) -> Dict:\n        return {\n            \'id\': self.id,\n            \'title\': self.title,\n            \'description\': self.description,\n            \'priority\': self.priority.name,\n            \'status\': self.status.value,\n            \'created_at\': self.created_at.isoformat(),\n            \'updated_at\': self.updated_at.isoformat(),\n            \'due_date\': self.due_date.isoformat() if self.due_date else None,\n            \'tags\': self.tags\n        }\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n    \n    def add_task(self, title: str, description: str = "", \n                 priority: Priority = Priority.MEDIUM) -> Task:\n        task = Task(title, description, priority)\n        self.tasks.append(task)\n        return task\n    \n    def get_tasks_by_status(self, status: TaskStatus) -> List[Task]:\n        return [task for task in self.tasks if task.status == status]\n    \n    def get_tasks_by_priority(self, priority: Priority) -> List[Task]:\n        return [task for task in self.tasks if task.priority == priority]\n    \n    def get_overdue_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if task.is_overdue()]\n    \n    def complete_task(self, task_id: str) -> bool:\n        for task in self.tasks:\n            if task.id == task_id:\n                task.update_status(TaskStatus.COMPLETED)\n                return True\n        return False\n    \n    def search_tasks(self, query: str) -> List[Task]:\n        query_lower = query.lower()\n        results = []\n        for task in self.tasks:\n            if (query_lower in task.title.lower() or \n                query_lower in task.description.lower() or \n                any(query_lower in tag.lower() for tag in task.tags)):\n                results.append(task)\n        return results\n    \n    def get_task_statistics(self) -> Dict[str, int]:\n        stats = {status.value: 0 for status in TaskStatus}\n        for task in self.tasks:\n            stats[task.status.value] += 1\n        return stats\n\ndef main():\n    manager = TaskManager()\n    \n    # Sample tasks\n    task1 = manager.add_task("Complete project proposal", \n                            "Write and submit the Q1 project proposal", \n                            Priority.HIGH)\n    task1.set_due_date(datetime.datetime.now() + datetime.timedelta(days=7))\n    task1.add_tag("work")\n    task1.add_tag("deadline")\n    \n    task2 = manager.add_task("Buy groceries", \n                            "Milk, bread, eggs, vegetables", \n                            Priority.MEDIUM)\n    task2.add_tag("personal")\n    task2.add_tag("shopping")\n    \n    # Display statistics\n    stats = manager.get_task_statistics()\n    print("Task Statistics:")\n    for status, count in stats.items():\n        print(f"  {status.replace(\'_\', \' \').title()}: {count}")\n\nif __name__ == "__main__":\n    main()',
	javascript:
		"class Calculator {\n    constructor() {\n        this.currentValue = 0;\n        this.previousValue = 0;\n        this.operation = null;\n        this.waitingForNewValue = false;\n        this.history = [];\n        this.maxHistorySize = 50;\n    }\n\n    clear() {\n        this.currentValue = 0;\n        this.previousValue = 0;\n        this.operation = null;\n        this.waitingForNewValue = false;\n    }\n\n    clearHistory() {\n        this.history = [];\n        this.updateHistoryDisplay();\n    }\n\n    inputNumber(number) {\n        if (this.waitingForNewValue) {\n            this.currentValue = number;\n            this.waitingForNewValue = false;\n        } else {\n            this.currentValue = this.currentValue * 10 + number;\n        }\n        this.updateDisplay();\n    }\n\n    inputDecimal() {\n        if (this.waitingForNewValue) {\n            this.currentValue = 0;\n            this.waitingForNewValue = false;\n        }\n        \n        if (this.currentValue.toString().indexOf('.') === -1) {\n            this.currentValue = this.currentValue + '.';\n        }\n        this.updateDisplay();\n    }\n\n    inputOperation(nextOperation) {\n        if (this.previousValue === 0) {\n            this.previousValue = this.currentValue;\n        } else if (this.operation) {\n            const result = this.calculate();\n            this.currentValue = result;\n            this.previousValue = result;\n        }\n\n        this.waitingForNewValue = true;\n        this.operation = nextOperation;\n        this.updateDisplay();\n    }\n\n    calculate() {\n        let result;\n        const prev = parseFloat(this.previousValue);\n        const current = parseFloat(this.currentValue);\n\n        if (isNaN(prev) || isNaN(current)) return;\n\n        switch (this.operation) {\n            case '+':\n                result = prev + current;\n                break;\n            case '-':\n                result = prev - current;\n                break;\n            case '*':\n                result = prev * current;\n                break;\n            case '/':\n                if (current === 0) {\n                    alert('Division by zero is not allowed!');\n                    return this.currentValue;\n                }\n                result = prev / current;\n                break;\n            case '%':\n                result = prev % current;\n                break;\n            default:\n                return;\n        }\n\n        this.addToHistory(prev + ' ' + this.operation + ' ' + current + ' = ' + result);\n        \n        this.currentValue = result;\n        this.operation = null;\n        this.previousValue = 0;\n        this.waitingForNewValue = true;\n        \n        return result;\n    }\n\n    calculateScientific(func) {\n        const current = parseFloat(this.currentValue);\n        let result;\n\n        switch (func) {\n            case 'sin':\n                result = Math.sin(this.toRadians(current));\n                break;\n            case 'cos':\n                result = Math.cos(this.toRadians(current));\n                break;\n            case 'sqrt':\n                if (current < 0) {\n                    alert('Square root of negative number is not allowed!');\n                    return;\n                }\n                result = Math.sqrt(current);\n                break;\n            default:\n                return;\n        }\n\n        this.addToHistory(func + '(' + current + ') = ' + result);\n        this.currentValue = result;\n        this.waitingForNewValue = true;\n        this.updateDisplay();\n    }\n\n    toRadians(degrees) {\n        return degrees * (Math.PI / 180);\n    }\n\n    addToHistory(entry) {\n        this.history.unshift(entry);\n        if (this.history.length > this.maxHistorySize) {\n            this.history.pop();\n        }\n        this.updateHistoryDisplay();\n    }\n\n    updateDisplay() {\n        const display = document.getElementById('display');\n        if (display) {\n            display.value = this.currentValue;\n        }\n    }\n\n    updateHistoryDisplay() {\n        const historyList = document.getElementById('history-list');\n        if (historyList) {\n            historyList.innerHTML = '';\n            this.history.forEach(entry => {\n                const listItem = document.createElement('li');\n                listItem.textContent = entry;\n                historyList.appendChild(listItem);\n            });\n        }\n    }\n}\n\n// Event listeners and initialization\ndocument.addEventListener('DOMContentLoaded', function() {\n    const calc = new Calculator();\n    \n    // Number buttons\n    for (let i = 0; i <= 9; i++) {\n        const button = document.getElementById('btn-' + i);\n        if (button) {\n            button.addEventListener('click', () => calc.inputNumber(i));\n        }\n    }\n    \n    // Operation buttons\n    const operations = ['+', '-', '*', '/', '%'];\n    operations.forEach(op => {\n        const button = document.getElementById('btn-' + op);\n        if (button) {\n            button.addEventListener('click', () => calc.inputOperation(op));\n        }\n    });\n    \n    window.calculator = calc;\n});",
	java: 'import java.util.*;\nimport java.time.LocalDateTime;\nimport java.math.BigDecimal;\nimport java.math.RoundingMode;\n\nabstract class Account {\n    protected String accountNumber;\n    protected String customerName;\n    protected BigDecimal balance;\n    protected List<Transaction> transactionHistory;\n    protected LocalDateTime createdAt;\n    \n    public Account(String accountNumber, String customerName, BigDecimal initialBalance) {\n        this.accountNumber = accountNumber;\n        this.customerName = customerName;\n        this.balance = initialBalance;\n        this.transactionHistory = new ArrayList<>();\n        this.createdAt = LocalDateTime.now();\n        \n        if (initialBalance.compareTo(BigDecimal.ZERO) > 0) {\n            addTransaction(new Transaction("INITIAL_DEPOSIT", initialBalance, "Initial deposit"));\n        }\n    }\n    \n    public abstract boolean withdraw(BigDecimal amount, String description);\n    public abstract BigDecimal getAvailableBalance();\n    \n    public boolean deposit(BigDecimal amount, String description) {\n        if (amount.compareTo(BigDecimal.ZERO) <= 0) {\n            throw new IllegalArgumentException("Deposit amount must be positive");\n        }\n        \n        balance = balance.add(amount);\n        addTransaction(new Transaction("DEPOSIT", amount, description));\n        return true;\n    }\n    \n    public boolean transfer(Account targetAccount, BigDecimal amount, String description) {\n        if (this.withdraw(amount, "Transfer to " + targetAccount.getAccountNumber())) {\n            targetAccount.deposit(amount, "Transfer from " + this.getAccountNumber());\n            return true;\n        }\n        return false;\n    }\n    \n    protected void addTransaction(Transaction transaction) {\n        transactionHistory.add(transaction);\n    }\n    \n    public String getAccountNumber() { return accountNumber; }\n    public String getCustomerName() { return customerName; }\n    public BigDecimal getBalance() { return balance; }\n}\n\nclass SavingsAccount extends Account {\n    private BigDecimal interestRate;\n    private BigDecimal minimumBalance;\n    \n    public SavingsAccount(String accountNumber, String customerName, \n                         BigDecimal initialBalance, BigDecimal interestRate) {\n        super(accountNumber, customerName, initialBalance);\n        this.interestRate = interestRate;\n        this.minimumBalance = new BigDecimal("100.00");\n    }\n    \n    @Override\n    public boolean withdraw(BigDecimal amount, String description) {\n        if (amount.compareTo(BigDecimal.ZERO) <= 0) {\n            return false;\n        }\n        \n        BigDecimal newBalance = balance.subtract(amount);\n        if (newBalance.compareTo(minimumBalance) < 0) {\n            return false;\n        }\n        \n        balance = newBalance;\n        addTransaction(new Transaction("WITHDRAWAL", amount.negate(), description));\n        return true;\n    }\n    \n    @Override\n    public BigDecimal getAvailableBalance() {\n        return balance.subtract(minimumBalance);\n    }\n    \n    public void applyInterest() {\n        BigDecimal interest = balance.multiply(interestRate).divide(new BigDecimal("100"), 2, RoundingMode.HALF_UP);\n        if (interest.compareTo(BigDecimal.ZERO) > 0) {\n            deposit(interest, "Monthly interest");\n        }\n    }\n}\n\nclass CheckingAccount extends Account {\n    private BigDecimal overdraftLimit;\n    \n    public CheckingAccount(String accountNumber, String customerName, \n                          BigDecimal initialBalance, BigDecimal overdraftLimit) {\n        super(accountNumber, customerName, initialBalance);\n        this.overdraftLimit = overdraftLimit;\n    }\n    \n    @Override\n    public boolean withdraw(BigDecimal amount, String description) {\n        if (amount.compareTo(BigDecimal.ZERO) <= 0) {\n            return false;\n        }\n        \n        BigDecimal newBalance = balance.subtract(amount);\n        if (newBalance.compareTo(overdraftLimit.negate()) < 0) {\n            return false;\n        }\n        \n        balance = newBalance;\n        addTransaction(new Transaction("WITHDRAWAL", amount.negate(), description));\n        return true;\n    }\n    \n    @Override\n    public BigDecimal getAvailableBalance() {\n        return balance.add(overdraftLimit);\n    }\n}\n\nclass Transaction {\n    private String type;\n    private BigDecimal amount;\n    private String description;\n    private LocalDateTime timestamp;\n    \n    public Transaction(String type, BigDecimal amount, String description) {\n        this.type = type;\n        this.amount = amount;\n        this.description = description;\n        this.timestamp = LocalDateTime.now();\n    }\n    \n    public String getType() { return type; }\n    public BigDecimal getAmount() { return amount; }\n    public String getDescription() { return description; }\n    public LocalDateTime getTimestamp() { return timestamp; }\n}\n\nclass Bank {\n    private String bankName;\n    private Map<String, Account> accounts;\n    private static int accountCounter = 1000;\n    \n    public Bank(String bankName) {\n        this.bankName = bankName;\n        this.accounts = new HashMap<>();\n    }\n    \n    public String createSavingsAccount(String customerName, BigDecimal initialDeposit, BigDecimal interestRate) {\n        String accountNumber = generateAccountNumber();\n        SavingsAccount account = new SavingsAccount(accountNumber, customerName, initialDeposit, interestRate);\n        accounts.put(accountNumber, account);\n        return accountNumber;\n    }\n    \n    private String generateAccountNumber() {\n        return String.format("ACC%05d", ++accountCounter);\n    }\n    \n    public Account getAccount(String accountNumber) {\n        return accounts.get(accountNumber);\n    }\n    \n    public BigDecimal getTotalDeposits() {\n        return accounts.values().stream()\n                .map(Account::getBalance)\n                .reduce(BigDecimal.ZERO, BigDecimal::add);\n    }\n}\n\npublic class BankingSystem {\n    public static void main(String[] args) {\n        Bank bank = new Bank("First National Bank");\n        \n        String savingsAccount = bank.createSavingsAccount("Alice Johnson", \n                                                         new BigDecimal("5000.00"), \n                                                         new BigDecimal("2.5"));\n        \n        Account account = bank.getAccount(savingsAccount);\n        account.deposit(new BigDecimal("1000.00"), "Salary deposit");\n        \n        System.out.println("Account Balance: $" + account.getBalance());\n        System.out.println("Available Balance: $" + account.getAvailableBalance());\n    }\n}',
	c: '#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_STUDENTS 50\n#define MAX_NAME_LENGTH 30\n\ntypedef struct {\n    int id;\n    char name[MAX_NAME_LENGTH];\n    float math_score;\n    float english_score;\n    float science_score;\n    float average;\n} Student;\n\nvoid calculate_average(Student *student) {\n    student->average = (student->math_score + \n                       student->english_score + \n                       student->science_score) / 3.0;\n}\n\nvoid print_student(const Student *student) {\n    printf("ID: %d\\n", student->id);\n    printf("Name: %s\\n", student->name);\n    printf("Math: %.2f\\n", student->math_score);\n    printf("English: %.2f\\n", student->english_score);\n    printf("Science: %.2f\\n", student->science_score);\n    printf("Average: %.2f\\n", student->average);\n    printf("------------------------\\n");\n}\n\nint find_highest_scorer(Student students[], int count) {\n    int highest_index = 0;\n    float highest_average = students[0].average;\n    \n    for (int i = 1; i < count; i++) {\n        if (students[i].average > highest_average) {\n            highest_average = students[i].average;\n            highest_index = i;\n        }\n    }\n    return highest_index;\n}\n\nvoid sort_students_by_average(Student students[], int count) {\n    for (int i = 0; i < count - 1; i++) {\n        for (int j = 0; j < count - i - 1; j++) {\n            if (students[j].average < students[j + 1].average) {\n                Student temp = students[j];\n                students[j] = students[j + 1];\n                students[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    Student students[MAX_STUDENTS] = {\n        {1, "Alice Johnson", 85.5, 92.0, 78.5, 0.0},\n        {2, "Bob Smith", 76.0, 83.5, 88.0, 0.0},\n        {3, "Carol Davis", 94.5, 89.0, 91.5, 0.0},\n        {4, "David Wilson", 82.0, 77.5, 85.0, 0.0},\n        {5, "Eva Brown", 88.5, 95.0, 87.5, 0.0}\n    };\n    \n    int student_count = 5;\n    \n    // Calculate averages\n    for (int i = 0; i < student_count; i++) {\n        calculate_average(&students[i]);\n    }\n    \n    printf("=== Student Grade Report ===\\n\\n");\n    \n    // Print all students\n    for (int i = 0; i < student_count; i++) {\n        print_student(&students[i]);\n    }\n    \n    // Find and display highest scorer\n    int highest_index = find_highest_scorer(students, student_count);\n    printf("Highest Scorer: %s (%.2f)\\n\\n", \n           students[highest_index].name, \n           students[highest_index].average);\n    \n    // Sort and display ranking\n    sort_students_by_average(students, student_count);\n    printf("=== Final Rankings ===\\n");\n    for (int i = 0; i < student_count; i++) {\n        printf("%d. %s (%.2f)\\n", i + 1, \n               students[i].name, students[i].average);\n    }\n    \n    return 0;\n}',
	cpp: '#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <memory>\n#include <map>\n\nclass Book {\nprivate:\n    static int nextId;\n    int id;\n    std::string title;\n    std::string author;\n    std::string isbn;\n    bool isAvailable;\n    \npublic:\n    Book(const std::string& title, const std::string& author, const std::string& isbn)\n        : id(++nextId), title(title), author(author), isbn(isbn), isAvailable(true) {}\n    \n    int getId() const { return id; }\n    const std::string& getTitle() const { return title; }\n    const std::string& getAuthor() const { return author; }\n    bool getAvailability() const { return isAvailable; }\n    \n    void setAvailability(bool available) { isAvailable = available; }\n    \n    bool matchesSearch(const std::string& query) const {\n        std::string lowerQuery = query;\n        std::transform(lowerQuery.begin(), lowerQuery.end(), lowerQuery.begin(), ::tolower);\n        \n        std::string lowerTitle = title;\n        std::string lowerAuthor = author;\n        std::transform(lowerTitle.begin(), lowerTitle.end(), lowerTitle.begin(), ::tolower);\n        std::transform(lowerAuthor.begin(), lowerAuthor.end(), lowerAuthor.begin(), ::tolower);\n        \n        return lowerTitle.find(lowerQuery) != std::string::npos ||\n               lowerAuthor.find(lowerQuery) != std::string::npos;\n    }\n};\n\nint Book::nextId = 0;\n\nclass Member {\nprivate:\n    static int nextMemberId;\n    int memberId;\n    std::string name;\n    std::string email;\n    std::vector<int> borrowedBooks;\n    \npublic:\n    Member(const std::string& name, const std::string& email)\n        : memberId(++nextMemberId), name(name), email(email) {}\n    \n    int getMemberId() const { return memberId; }\n    const std::string& getName() const { return name; }\n    bool canBorrowMore() const { return borrowedBooks.size() < 5; }\n    \n    void borrowBook(int bookId) {\n        if (canBorrowMore()) {\n            borrowedBooks.push_back(bookId);\n        }\n    }\n    \n    bool returnBook(int bookId) {\n        auto it = std::find(borrowedBooks.begin(), borrowedBooks.end(), bookId);\n        if (it != borrowedBooks.end()) {\n            borrowedBooks.erase(it);\n            return true;\n        }\n        return false;\n    }\n};\n\nint Member::nextMemberId = 0;\n\nclass Library {\nprivate:\n    std::vector<std::unique_ptr<Book>> books;\n    std::vector<std::unique_ptr<Member>> members;\n    std::map<int, int> borrowRecords;\n    \npublic:\n    void addBook(const std::string& title, const std::string& author, const std::string& isbn) {\n        books.push_back(std::make_unique<Book>(title, author, isbn));\n        std::cout << "Book added successfully: " << title << std::endl;\n    }\n    \n    void addMember(const std::string& name, const std::string& email) {\n        members.push_back(std::make_unique<Member>(name, email));\n        std::cout << "Member added successfully: " << name << std::endl;\n    }\n    \n    std::vector<Book*> searchBooks(const std::string& query) {\n        std::vector<Book*> results;\n        for (const auto& book : books) {\n            if (book->matchesSearch(query)) {\n                results.push_back(book.get());\n            }\n        }\n        return results;\n    }\n    \n    bool borrowBook(int bookId, int memberId) {\n        auto bookIt = std::find_if(books.begin(), books.end(),\n            [bookId](const std::unique_ptr<Book>& book) {\n                return book->getId() == bookId;\n            });\n            \n        auto memberIt = std::find_if(members.begin(), members.end(),\n            [memberId](const std::unique_ptr<Member>& member) {\n                return member->getMemberId() == memberId;\n            });\n        \n        if (bookIt != books.end() && memberIt != members.end()) {\n            Book* book = bookIt->get();\n            Member* member = memberIt->get();\n            \n            if (book->getAvailability() && member->canBorrowMore()) {\n                book->setAvailability(false);\n                member->borrowBook(bookId);\n                borrowRecords[bookId] = memberId;\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    void displayAllBooks() const {\n        std::cout << "\\n=== All Books ===" << std::endl;\n        for (const auto& book : books) {\n            std::cout << book->getTitle() << " by " << book->getAuthor() \n                     << " [" << (book->getAvailability() ? "Available" : "Borrowed") << "]" << std::endl;\n        }\n    }\n};\n\nint main() {\n    Library library;\n    \n    library.addBook("The C++ Programming Language", "Bjarne Stroustrup", "978-0321563842");\n    library.addBook("Effective C++", "Scott Meyers", "978-0321334879");\n    library.addBook("Clean Code", "Robert C. Martin", "978-0132350884");\n    \n    library.addMember("Alice Johnson", "alice@example.com");\n    library.addMember("Bob Smith", "bob@example.com");\n    \n    library.displayAllBooks();\n    \n    if (library.borrowBook(1, 1)) {\n        std::cout << "Book 1 borrowed by Member 1" << std::endl;\n    }\n    \n    auto searchResults = library.searchBooks("C++");\n    std::cout << "\\n=== Search Results for \'C++\' ===" << std::endl;\n    for (const auto& book : searchResults) {\n        std::cout << book->getTitle() << std::endl;\n    }\n    \n    return 0;\n}',
	rust: 'use std::collections::HashMap;\nuse std::fmt;\n\n#[derive(Debug, Clone)]\npub enum ConfigValue {\n    String(String),\n    Integer(i64),\n    Float(f64),\n    Boolean(bool),\n    List(Vec<String>),\n}\n\nimpl fmt::Display for ConfigValue {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        match self {\n            ConfigValue::String(s) => write!(f, "{}", s),\n            ConfigValue::Integer(i) => write!(f, "{}", i),\n            ConfigValue::Float(fl) => write!(f, "{}", fl),\n            ConfigValue::Boolean(b) => write!(f, "{}", b),\n            ConfigValue::List(list) => {\n                let joined = list.join(", ");\n                write!(f, "[{}]", joined)\n            }\n        }\n    }\n}\n\n#[derive(Debug)]\npub enum ConfigError {\n    ParseError(String),\n    KeyNotFound(String),\n    InvalidType(String),\n}\n\nimpl fmt::Display for ConfigError {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        match self {\n            ConfigError::ParseError(msg) => write!(f, "Parse Error: {}", msg),\n            ConfigError::KeyNotFound(key) => write!(f, "Key not found: {}", key),\n            ConfigError::InvalidType(msg) => write!(f, "Invalid type: {}", msg),\n        }\n    }\n}\n\npub struct ConfigManager {\n    data: HashMap<String, ConfigValue>,\n    file_path: String,\n    is_modified: bool,\n}\n\nimpl ConfigManager {\n    pub fn new(file_path: &str) -> Self {\n        ConfigManager {\n            data: HashMap::new(),\n            file_path: file_path.to_string(),\n            is_modified: false,\n        }\n    }\n\n    pub fn set(&mut self, key: &str, value: ConfigValue) {\n        self.data.insert(key.to_string(), value);\n        self.is_modified = true;\n    }\n\n    pub fn get(&self, key: &str) -> Result<&ConfigValue, ConfigError> {\n        self.data.get(key).ok_or_else(|| ConfigError::KeyNotFound(key.to_string()))\n    }\n\n    pub fn get_string(&self, key: &str) -> Result<&String, ConfigError> {\n        match self.get(key)? {\n            ConfigValue::String(s) => Ok(s),\n            _ => Err(ConfigError::InvalidType(format!("Key \'{}\' is not a string", key)))\n        }\n    }\n\n    pub fn get_integer(&self, key: &str) -> Result<i64, ConfigError> {\n        match self.get(key)? {\n            ConfigValue::Integer(i) => Ok(*i),\n            _ => Err(ConfigError::InvalidType(format!("Key \'{}\' is not an integer", key)))\n        }\n    }\n\n    pub fn get_boolean(&self, key: &str) -> Result<bool, ConfigError> {\n        match self.get(key)? {\n            ConfigValue::Boolean(b) => Ok(*b),\n            _ => Err(ConfigError::InvalidType(format!("Key \'{}\' is not a boolean", key)))\n        }\n    }\n\n    pub fn remove(&mut self, key: &str) -> Option<ConfigValue> {\n        self.is_modified = true;\n        self.data.remove(key)\n    }\n\n    pub fn keys(&self) -> Vec<&String> {\n        self.data.keys().collect()\n    }\n\n    pub fn is_modified(&self) -> bool {\n        self.is_modified\n    }\n\n    pub fn clear(&mut self) {\n        self.data.clear();\n        self.is_modified = true;\n    }\n\n    fn parse_value(&self, value_str: &str) -> Result<ConfigValue, String> {\n        let trimmed = value_str.trim();\n\n        match trimmed.to_lowercase().as_str() {\n            "true" => return Ok(ConfigValue::Boolean(true)),\n            "false" => return Ok(ConfigValue::Boolean(false)),\n            _ => {}\n        }\n\n        if trimmed.starts_with(\'[\') && trimmed.ends_with(\']\') {\n            let inner = &trimmed[1..trimmed.len()-1];\n            let items: Vec<String> = inner\n                .split(\',\')\n                .map(|s| s.trim().to_string())\n                .filter(|s| !s.is_empty())\n                .collect();\n            return Ok(ConfigValue::List(items));\n        }\n\n        if let Ok(int_val) = trimmed.parse::<i64>() {\n            return Ok(ConfigValue::Integer(int_val));\n        }\n\n        if let Ok(float_val) = trimmed.parse::<f64>() {\n            return Ok(ConfigValue::Float(float_val));\n        }\n\n        Ok(ConfigValue::String(trimmed.to_string()))\n    }\n}\n\nfn main() -> Result<(), ConfigError> {\n    let mut config = ConfigManager::new("app_config.txt");\n    \n    config.set("app_name", ConfigValue::String("My Application".to_string()));\n    config.set("version", ConfigValue::String("1.0.0".to_string()));\n    config.set("port", ConfigValue::Integer(8080));\n    config.set("debug_mode", ConfigValue::Boolean(true));\n    config.set("allowed_hosts", ConfigValue::List(vec![\n        "localhost".to_string(),\n        "127.0.0.1".to_string(),\n        "0.0.0.0".to_string()\n    ]));\n    \n    println!("Current Configuration:");\n    for key in config.keys() {\n        if let Ok(value) = config.get(key) {\n            println!("{}: {}", key, value);\n        }\n    }\n    \n    if let Ok(app_name) = config.get_string("app_name") {\n        println!("Application Name: {}", app_name);\n    }\n    \n    if let Ok(port) = config.get_integer("port") {\n        println!("Port: {}", port);\n    }\n    \n    if let Ok(debug) = config.get_boolean("debug_mode") {\n        println!("Debug Mode: {}", debug);\n    }\n    \n    Ok(())\n}',
	lua: '-- Game Score Management System in Lua\n\nPlayer = {}\nPlayer.__index = Player\n\nfunction Player:new(name, level)\n    local player = {\n        name = name or "Anonymous",\n        level = level or 1,\n        experience = 0,\n        score = 0,\n        achievements = {},\n        statistics = {\n            games_played = 0,\n            games_won = 0,\n            total_playtime = 0,\n            highest_score = 0,\n            average_score = 0\n        },\n        inventory = {},\n        created_at = os.time()\n    }\n    setmetatable(player, Player)\n    return player\nend\n\nfunction Player:add_experience(exp)\n    self.experience = self.experience + exp\n    local old_level = self.level\n    \n    self.level = math.floor(math.sqrt(self.experience / 100)) + 1\n    \n    if self.level > old_level then\n        print(string.format("%s leveled up! New level: %d", self.name, self.level))\n        self:unlock_achievement("level_up")\n        return true\n    end\n    return false\nend\n\nfunction Player:add_score(points)\n    self.score = self.score + points\n    if self.score > self.statistics.highest_score then\n        self.statistics.highest_score = self.score\n        if self.score > 10000 then\n            self:unlock_achievement("high_score")\n        end\n    end\nend\n\nfunction Player:unlock_achievement(achievement_id)\n    if not self.achievements[achievement_id] then\n        self.achievements[achievement_id] = {\n            unlocked_at = os.time(),\n            count = 1\n        }\n        print(string.format("%s unlocked achievement: %s", self.name, achievement_id))\n    else\n        self.achievements[achievement_id].count = self.achievements[achievement_id].count + 1\n    end\nend\n\nfunction Player:finish_game(score, won, playtime)\n    self.statistics.games_played = self.statistics.games_played + 1\n    self.statistics.total_playtime = self.statistics.total_playtime + playtime\n    \n    if won then\n        self.statistics.games_won = self.statistics.games_won + 1\n        self:unlock_achievement("game_win")\n    end\n    \n    self:add_score(score)\n    self:add_experience(score / 10)\n    \n    if self.statistics.games_played >= 100 then\n        self:unlock_achievement("veteran")\n    end\n    \n    if self.statistics.games_won >= 50 then\n        self:unlock_achievement("winner")\n    end\nend\n\nfunction Player:get_win_rate()\n    if self.statistics.games_played == 0 then\n        return 0\n    end\n    return (self.statistics.games_won / self.statistics.games_played) * 100\nend\n\nfunction Player:to_string()\n    local achievements_list = {}\n    for achievement, data in pairs(self.achievements) do\n        table.insert(achievements_list, string.format("%s(%d)", achievement, data.count))\n    end\n    \n    return string.format(\n        "Player: %s | Level: %d | Score: %d | Experience: %d | Win Rate: %.1f%%",\n        self.name, self.level, self.score, self.experience, self:get_win_rate()\n    )\nend\n\nGameSession = {}\nGameSession.__index = GameSession\n\nfunction GameSession:new(player, game_type)\n    local session = {\n        player = player,\n        game_type = game_type or "default",\n        start_time = os.time(),\n        end_time = nil,\n        score = 0,\n        events = {},\n        status = "active"\n    }\n    setmetatable(session, GameSession)\n    return session\nend\n\nfunction GameSession:add_event(event_type, description, points)\n    points = points or 0\n    local event = {\n        type = event_type,\n        description = description,\n        points = points,\n        timestamp = os.time()\n    }\n    table.insert(self.events, event)\n    self.score = self.score + points\nend\n\nfunction GameSession:finish(won)\n    self.end_time = os.time()\n    self.status = won and "won" or "lost"\n    local playtime = self.end_time - self.start_time\n    \n    self.player:finish_game(self.score, won, playtime)\n    \n    return {\n        duration = playtime,\n        final_score = self.score,\n        result = self.status,\n        events_count = #self.events\n    }\nend\n\nfunction main()\n    local alice = Player:new("Alice", 1)\n    local bob = Player:new("Bob", 1)\n    \n    math.randomseed(os.time())\n    \n    for i = 1, 10 do\n        local players = {alice, bob}\n        local player = players[math.random(#players)]\n        \n        local session = GameSession:new(player, "puzzle")\n        \n        for j = 1, math.random(3, 8) do\n            session:add_event("action", "Player action " .. j, math.random(50, 200))\n        end\n        \n        local won = math.random() > 0.4\n        session:finish(won)\n    end\n    \n    print("=== Player Information ===")\n    print(alice:to_string())\n    print(bob:to_string())\nend\n\nmain()',
	typewell: "DYNAMIC_GENERATION", // TypeWellオリジナルモード - 動的生成
	"typewell-english-words": "DYNAMIC_GENERATION", // TypeWell English Wordsモード - 動的生成
	"initial-speed": "DYNAMIC_GENERATION", // Initial Speedモード - 動的生成
	"word-practice": "DYNAMIC_GENERATION", // Word Practiceモード - 動的生成
};
